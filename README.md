
# UDEMY
 ğŸ“š Aqui adicionarei resumo dos exercÃ­cios dos cursos da [UDEMY](https://www.udemy.com/).

ğŸ’» curso_programacao - Professor NÃ©lio Ãlves: [Java COMPLETO ProgramaÃ§Ã£o Orientada a Objetos + Projetos](https://www.udemy.com/course/java-curso-completo/)


ğŸ“1 _ Estrutura Sequencial:
- Entrada de dados, quando o usuÃ¡rio informa dados ao computador. Exemplos bÃ¡sicos para entendimento de leitura de dados.
- Processamento de dados, forma em que as variÃ¡veis recebem os valores. Exemplos bÃ¡sicos para entendimento de atribuiÃ§Ã£o de dados.
- SaÃ­da de dados, quando o computador informa dados ao usuÃ¡rio. Exemplos bÃ¡sicos para entendimento de escrita de dados.

ğŸ“ 1.1 _ ExpressÃ£o MatemÃ¡tica usando Math:
- sqrt = a variÃ¡vel recebe o valor da raiz quadrada
- pow =  a variÃ¡vel recebe valor de uma variÃ¡vel elevada ao valor de outra variÃ¡vel
- abs =  a variÃ¡vel recebe o valor absoluto

ğŸ“ 1.2 _ Estrutura condicional =  estrutura de controle, que permite a definiÃ§Ã£o e execuÃ§Ã£o de blocos de comandos, com uma condiÃ§Ã£o:

ğŸ“ 1.3 _ ExpressÃµes comparativas: 
- maior >
- menor <
-  maior ou igual >=
-  menor ou igual <=
-  igual ==
-  diferente !=

ğŸ“ 1.4 _ ExpressÃµes LÃ³gicas:
- CondiÃ§Ã£o && ( E ) = Todas as condiÃ§Ãµes tem que ser VERDADEIRAS
- CondiÃ§Ã£o || ( OU ) = Pelo menos uma condiÃ§Ã£o deve ser VERDADEIRA
- CondiÃ§Ã£o ! ( NÃƒO ) = Inverte a condiÃ§Ã£o, se a expressÃ£o for verdadeira, passarÃ¡ a ser falsa e virce e versa.

ğŸ“ 1.5 _ Condicional Simples
- if(){} = se

ğŸ“ 1.6 _ Condicional Composta
- if(){ = se
- }else{} = se nÃ£o

ğŸ“ 1.7 _ CondiÃ§Ã£o de encadeamento
- if(){ = se
- }else if(){ = se nÃ£o se
- }else {}= se nÃ£o

ğŸ“ 1.8 _ CondiÃ§Ã£o Comulativa
- a += b; a = a + b (a recebe a + b )
-	a -= b; a = a - b (a recebe a - b )
- a *= b; a = a * b (a recebe a * b )
- a /= b; a = a / b (a recebe a / b )
- a %= b; a = a % b (a recebe a % b )

ğŸ“ 1.9 _ Switch - Case
- switch(){
- case 1:
- exemplo = 'exemplo';
- break;
- default: 
- exemplo = "exemplo2";
- break;}

ğŸ“ 1.10_ CondiÃ§Ã£o TernÃ¡ria
- (condiÃ§Ã£o) ? valor_se_verdadeiro : valor_se_falso

ğŸ“ 2 _ Estrutura de Controle de repetiÃ§Ã£o
- while = estrutura de controle que executa um bloco de cÃ³digo (comandos), enquanto uma condiÃ§Ã£o for verdadeira. Usar quando nÃ£o se sabe previamente a quantidade de repetiÃ§Ãµes a serem executadas.

- for = estrutura de controle que repete um bloco de cÃ³digo (comandos), para um certo intervalo de valores. Usar quando se sabe a quantidade repetiÃ§Ãµes ou o intervalo de valores, podedo incrementar ou decrementar.

- do while = estrutura de controle que executa o bloco de comandos executa pelo menos 1 vez,  pois a condiÃ§Ãµa Ã© verificada no final,  primeiro executa o bloco, depois verifica passa pelo bloco, quando a condiÃ§Ã£o for verdadeira,a estrutura volta e executa  novamente se a condiÃ§Ã£o for falsa sai do bloco.

ğŸ“ 3 _ ConversÃ£o de String

- toLowerCase =  converte tudo para minÃºsculo.
- toUpperCase = converte tudo para maiÃºsculo.
- trim = mantem a string original removendo os espaÃ§os do final.
- subString = pega somente da posiÃ§Ã£o declarada e monta uma nova string.
- replace = troca a string de posiÃ§Ã£o por seleÃ§Ã£o.
- indexOf = primeira posiÃ§Ã£o da ocorrÃªncia.
- lastIndexOf = Ãºltima posiÃ§Ã£o da ocorrÃªncia
- split =  funÃ§Ã£o para recortar a string, criando um vetor, sendo assim colocando as partes da string em vÃ¡rias posiÃ§Ãµes de acordo com a quantidade de valores na variÃ¡vel.

ğŸ“ 4 _ FunÃ§Ãµes 

- Representam um processamento que possui um significado.
- OperaÃ§Ãµes que pode ser reaproveitada vÃ¡rias vezes.
- Recebe um argumento como parÃ¢metro e retorna uma resposta.

ğŸ“ 4.1 Vantagens:

- ModulariazaÃ§Ã£o: divide em vÃ¡rios mÃ³dulos.
- DelegaÃ§Ã£o: lÃ³gica para execuÃ§Ã£o em outro lugar.
- Reaproveitameto: podendo ser utulizado vÃ¡rias vezes.
- Podem receber dados de entrada (parÃ¢metros ou argumentos) e saÃ­da
(podendo ou nÃ£o retornar uma saÃ­da)
- Em POO funÃ§Ãµes em classes sÃ£o os mÃ©todos.

ğŸ“ 5 _ Classes

- Tipo estruturado
- Atributos(dados/campos)
- MÃ©todos(funÃ§Ãµes/operaÃ§Ãµes)
- Construtores
- Sobrecarga
- Encapsulamento
- HeranÃ§a
- Polimorfismo

Entidades
ServiÃ§os
Controladores
UtilitÃ¡rios
Views
RepositÃ³rios
Gerenciaodres

- Toda classe em java Ã© uma subclasse da classe Object 

ğŸ“ 5.1 _ Objeto

- SÃ£o as instÃ¢ncias das classes

- getClass =  retorna o tipo do objeto
- equals = compara se o objero Ã© igual a outro
- hasCode = retorna um cÃ³digo has do objeto
- toString - converte o objeto para String

ğŸ“ 5.2 InstanciaÃ§Ã£o
- MemÃ³ria Stack = estÃ¡tica
- MemÃ³ria Heap = dinÃ¢mica 

ğŸ“ 6 _ Projeto de Classes UML = Diagrama de Classes

- Representa classes, e relaÃ§Ãµes entre elas

ğŸ“ 7 _ Membros estÃ¡ticos

- SÃ£o conhecidos como membros de classes
- public static final = nÃ£o pode mudar (uma constante), (para declarar nomes inal, sempre ser com letras maiusculas)
- padrÃ£o de nomeclatura para constantes = tudo maiusculas com um _ para separar as palavras, exemplo: NET_SALARY.
- Ao ser declarado, um mÃ©todo statico (ou uma constante), nÃ£o precisa de um objeto para ser chamado em outra classe, sendo assim apenas chamamos a propria classe.mÃ©todo desejado, passando os parametros.

ğŸ“ 8 _ SobreCarga

- Ã‰ um recuso que uma classe possui de oferecer mais de uma operaÃ§Ã£o (construtor) com o mesmo nome, porÃ©m com diferentes listas de parametros 

ğŸ“ 9 _ Encapsulamento

- Esconde detalhes de implementaÃ§Ã£o de uma classe.
- Expor somente operaÃ§Ãµes seguros
- garabtir e mater que os objetos estejam em um estado consistente, nÃ£o podendo ter dados invÃ¡lidos
- Objeto nÃ£o deve expor nenhum atributo(private)
- Atributos acessados somente por mÃ©todos get e set

ğŸ“ 10 _ Modificadores de Acesso

- Private = sÃ³ pde ser acessado na prÃ³pria classe
- NÃ£o especificar o modificador = sÃ³ pde ser acessado na classe do mesmo pacote
- Protected = sÃ³ pode ser acessado no mesmo pacote, bem como subclasses de pacotes diferentes (extends = heranÃ§a)
- Public = acessado por todas as classes, ao menos que ele esteja em um mÃ³dulo diferente que nÃ£o exporte o pacote onde ele estÃ¡

ğŸ“ 11 _ Tipos referÃªncia vs tipos valor

*** STACK Ã© uma area de memÃ³ria que guarda as variÃ¡veis declarada em cada classe
Quando declaramos um objeto, ele Ã© guardado(alocado) em um local de memÃ³ria chamado HEAP em tempo de execuÃ§Ã£o , isso Ã© chamdado de alocaÃ§Ã£o dinÃ¢mica de memÃ³ria . ***

ğŸ“ 11.1 _ Classes

- Em java as classes sÃ£o tipos referencias
- VariÃ¡veis do tipo classes sÃ£o referencias ou tentÃ¡culos ou ponteiros, pois dentro dela vai ter uma referencia , um  endereÃ§o que vai dizer/apontar onde estÃ¡ o objeto 

ğŸ“ 11.2 _ Valor null

- Tipos referncias(classes) aceitam valores "null", que indica que a variÃ¡vel aponta para ninguÃ©m, inicialmnete.
- Tipos valor(tipos primitivos) nÃ£o aceitam valores "null", necessita ser declarada inicialmente

ğŸ“ 11.3 _ Tipos primitivos

- Em java os tipos primitivos sÃ£o tipos valor, caixas
- As variavÃ©s serÃ£o caixas alocadas na Ã¡rea de memÃ³ria STACK, dentro serÃ¡ guardado o tipo exemplo booÃ§ean, char, byte, short, long, float, double, int

ğŸ“ 11.4 _ Valores padrÃ£o

- Quando alocamos(new) qualquer tipo estruturado(classe ou arry), sÃ£o atribuiidos valores padrÃ£o aos apontamentos
- Quando instanciamos um objeto por pardrÃ£o serÃ¡ inicializado com:
- numero: 0
- boolean: false
- char caracter cÃ³digo unicode 0
- objeto: null

ğŸ“ 12 _ DesalocaÃ§Ã£o de MemÃ³ria - garbage collector e escopo local

ğŸ“ 12.1 _ DeslocaÃ§Ã£o garbage collector 

- Processo que automatiza o gerenciamento de memÃ³ria de um progama em execuÃ§Ã£o , monitorando os objetos alocados dinamicamente(tempo de execuÃ§Ã£o) pelo programa (no heap), deslocando aqueles que nÃ£o estÃ£o mais sendo utilizados

ğŸ“ 12.1 _DeslocaÃ§Ã£o por escopo local

- VariÃ¡veis estÃ¡ticamente declaradas
- VariÃ¡veis locais sÃ£o desalocadas imediatamente assim que seu escopo local sai de execuÃ§Ã£o

ğŸ“ 13 _ Vetores

- Arranjos unidimencionais

ğŸ“ 13.1 _ Arrays(Arranjos)

- Estrtura de dados :

- Homogenia = mesmo tipo
- Ordenados = acessados por meio de posiÃ§Ãµes
- Alocada de uma vez sÃ³ em um bloco contÃ­guo de memÃ³ria

Vantagens : acesso imediato aos elementos de sua posiÃ§Ã£o
Desvantagem : tamanho fixo, dificuldade para realizar inserÃ§Ãµoes e deleÃ§Ãµes

ğŸ“ 14 _ Boxing (encaixotamento)

- Ã‰ o processo de conversÃ£o de um objeto tipo valor para um objeto tipo referencia compatÃ­vel

ğŸ“ 15 _ Unboxing

- Ã‰ o processo de conversÃ£o de um objeto tipo referencia para um objeto tipo valor compatÃ­vel

ğŸ“ 16 _ Wrapper Classes

- SÃ£o classes com o objetivo de fazer o tratamento dos tipos primitivos como classes de forma transparente ao compilador sem a necessidade de utilizaÃ§Ã£o de casting
- SÃ£o classes equivalente aos tipos primitivos(de vez com letras minusculas usar com letras maiusculas), sendo assim passam a ser uma classe e nÃ£o apenas tipos primitivos
- Para serem feitos boxing e unboxing de forma natural no java		
- Aceita valor null

ğŸ“ 17 _ For each

- Sintaxe simplificada para percorrer coleÃ§Ãµes
 for(tipo apelido : coleÃ§Ã£o){
    <comando 1>
    <comando 2>
 }

ğŸ“ 18 _ Listas

- Estrutuda de dados 
    HomogÃªnia
    Ordenadaa
    Inicia vazia
    Cada elemento ocupa um nÃ³

- Tipo interface (List)
- Classes que implementam a interface List, ArrayList, LinkedList ...

ğŸ“ 18.1 DemostraÃ§Ã£o

- size() => Tamanho da lista
- add() => insere elementos a lista
- remove() => remove elementos da lista
- removeIf( x -> x.charAt(0) == 'M') => remove todo String(tipo) "nome do objeto" tal que "nome do objeto".(tipo primitivo) seja igual a ...
- index0f(), lastInndexOf() => encontra posiÃ§Ã£o de elementos
- List<Integer> result = list.stream().filter(x -> x > 4).collect(Collectors.toList()); => Filtrar lista com base em predicado
- Integer result = list.stream().filter(x -> x > 4).findFirst().orElse(null); => encontra primeira ocorrencia com base em predicado

ğŸ“ 19 _ Matriz
 
- nome dado a arranjos bidimencionais, vetores de vetores
- Linhas e colunas
